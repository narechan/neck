Neck: recombination detection and measurement using the 
      sequential information bottleneck (IB).

## INTRODUCTION TO NECK ##

Neck is a program that leverages lossy compression and clustering concepts
devised in information theory and natural language processing. Neck specifically
clusters k-mers from a set of genomes yielding groups that illuminate both vertical
and horizontal evolutionary signal.

## LICENSE ##

Neck is written in PERL and available as CC-BY-NC.

## QUICK START ##

example_fig1:
neck -i genomes/ -k 19 -c 2 -n 5 -s 10 -o output_dir
neck_paint -i genomes/ -c output_dir/clusters/ -l 200 -r /path/to/changepoint.R 
	   -p processors -m 2 -v 500 -o output_dir

## MAIN PROGRAMS ##

neck clusters k-mers using the information bottleneck.

neck_paint maps and visualizes kmer clusters back on the source genomes with 
	   bowtie2, samtools and circos.

changepoint.R employs the PELT algorithm to map boundaries of potential 
recombination events.

## INSTALLATION ##

We recommend docker. The included dockerfile can be used to create an image 
with a fully configured environment containing all the necessary software 
and dependencies.

To build the image:
docker build -t neck-0.2 .
docker run -it --mount src=`pwd`,target=/home/data,type=bind neck-0.2

Installing from source is also an option but requires the following 
dependencies for each program:

neck requires perl modules: Getopt::Std; Statistics::Descriptive;
     Digest::MurmurHash3; and strict
neck_paint requires R, the R changepoint package, circos, bowtie2, and
     samtools. It also requires the addition perl modules Statistics::R 
     and Parallel::ForkManager
	    
## EXECUTING NECK ON THE TEST DATA ##

Test data to recapitulate Figure 1 is provided with the distribution.
To reproduce the results shown in Figure 1 issue the following commands
from within example_fig1:

neck -i genomes/ -k 19 -c 2 -n 5 -s 10 -o output_dir
neck_paint -i genomes/ -c output_dir/clusters/ -l 200 -r /path/to/changepoint.R
           -p processors -m 2 -v 500 -o output_dir

This command will generate multiple files that are detailed below in the 
section on output. 

Parameters for neck:
	-i directory containing your genome fasta files (one genome per file)
	   sequence should be on one line! 
	-o path to the output directory (will be created)
	-k k-mer size
	-c the number of clusters to model during the bottleneck procedure
	-n the number of iterations to run the bottleneck procedure
	-s is the sketch rate

Parameters for neck_paint:
	-i input directory containing genomes
	-o output directory for results
	-c path to the output directory containing fasta files of clusters.
	   after a neck run, this will be found in output_dir/clusters
	-l bin length for the circos density plots
	-m is the max range for circos density plots
	-r is the path to the changepoint script
	-v is the penalty parameter supplied to the changepoint algorithm.
	   if you want to optimize this parameter with the bayesian 
	   information criterion, use "-v BIC"
	-x known recombination regions file. if recombination regions are 
	   known, then a file of their start and stop coordinates can be
	   given here.
	-h usage HELP   

## OUTPUT ##

From neck:
1. clusters/ contains the k-mer clusters number from 0-x where x is the 
   number of clusters modelled.
2. core/ contains the k-mer cluster determined to be the core genome.
3. hashes/ contains the hashes of strings sketched from the genomes.
4. tfreq/ contains tables detailing the number of hits to each genome
   foreach cluster. 0-x where x is the number of clusters modelled.

From neck_paint:
neck_paint does an all clusters against all genomes mapping analysis. If genome
names are query.1-query.y and clusters are 0.fa-0.x

query.y-cluster.x.c_config is the autogenerated circos config file
query.y-cluster.x.karyotype is the autogenerated circos karyotype file
query.y-cluster.x.depth is the mapped k-mer depth at each reference position
query.y-cluster.x.density is the average frequency of k-mers in -l defined windows
query.y-cluster.x.chpts are the changepoints calculated by the PELT algorithm
query.y-cluster.x.chpts.draw are changepoint coordinates for circos
query.y-cluster.x.chpts.intervals are the changepoint derived intervals comprising 
	a recombination breakpoint analysis
query.y-cluster.x.chpts.chunks is a table of the average kmer frequency density 
	between changepoints
query.y-cluster.x.png is an image showing k-mer frequency and changepoints
	foreach genome/cluster pair.

The stats.out file contains data useful for monitoring the progress 
of the bottleneck run, data for characterizing the core genome, and data that 
measures the compressibility of the dataset. The stat.out file contains
the following:

1. The number of unique kmers in the input genomes (uniqkmers).
2. The mutual information between the unclustered k-mers and their 
   source genomes (kMI).
3. The entropy of all the k-mers (kEnt).
4. The next few lines show the progress of the bottleneck clustering 
   process. There is one line per iteration, each of which contain the
   following fields:
   a. iteration number
   b. the mutual information between the k-mer clusters and source genomes
      (clustMI). The number in parenthases is the normalized mutual information
      with respect to kMI.
5. The final NMI (NMI=..).
6. The final line provides information about the core genome. The fields 
   are as follows:
   a. the index number of the cluster which comprises the core
   b. the average number of times a k-mer in the core cluster exists 
      in each genome.
   c. the variance of b.
   d. the number of unique k-mers in the core.
   e. the fraction of all unique k-mers that are in the core.
   f. the number of k-mers in the core that are shared by all the genomes.
   g. the fraction of all unique k-mers shared by all the genomes.

## FAQS ##

1. Is there really only one toy example?

   No! The distribution also contains two other examples from the paper.
   Genomes in example_suppfig2 and example_fig5 can recreate the images from
   Supplemental Figure 2 and Figure 5A, respectively. 

   neck -i genomes/ -k 19 -c [5||10] -n 5 -s 10 -o output_dir
   neck_paint -i genomes/ -c outputdir/clusters/ -l 200 -r /path/to/changepoint.R 
	   -p procs -m 2 -v [BIC||500] -o s10/

   Note that for supplemental figure 2 -c is set to 5 and for figure 5A -c 
   is set to 10.

   The penalty parameter can be optimized by the BIC or we recommend trying 
   a manual value of 500 for these two examples.

2. How do I figure out how to set the number of clusters?

   We recommend a parameter sweep to build a relevance compression curve for 
   your genomes. In the Figure 5A example data, the recipe for a parameter sweep 
   would look like this:

   for i in `cat list.clusters`; do neck -i genomes/ -k 19 -c $i -n 5 -s 10 
        -o relavence_compression/$i & done
   grep NMI relavence_compression/*/stats.out

   Wherever you are satisfied with the elbow is you optimal -c.

3. How should I set the sketch rate?

   All examples in the paper are set to subsample at a rate of 10. This is a 
   modulo hashing operation. Setting at 1 does no sketching, and setting at 100
   does a 10 times thinner sketch. We recommend trying 10 first as this is a good
   compromise between computational savings and resolution. See the manuscript for 
   more details.

4. How do I set the PELT penalty parameter?
   
   You can use BIC (the bayesian information criterion) to optimize the penalty 
   parameter. But in our experience, this overcalls changepoints severely. 
   We recommend trying a number of penalty parameters and visualizing the results.
   A penalty parameter of 500 works well for the three examples in the 
   distribution. But it can take a long time. Especially for the Figure 5A dataset.

## Citation ##
   
https://www.biorxiv.org/content/10.1101/2021.08.27.457981v2
